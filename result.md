# シフト最適化の実行結果と制約分析

##### 使用ソルバー: OR-Tools CP-SAT

## 使用された主な最適化手法

1. **局所探索(Local Search)**
   * `ls_restart`, `ls_lin_restart`, `ls_restart_decay`
   * 現在の解の近傍を探索する。小さな変更を繰り返して解を改善。高速だが局所最適解に陥りやすい。
2. **大規模近傍探索(Large Neighborhood Search)**
   * `graph_dec_lns`, `graph_arc_lns`, `graph_var_lns`, `graph_cst_lns`, `rnd_var_lns`, `rnd_cst_lns`
   * より広範囲の解空間を探索。一部の変数を固定化して部分問題を解く。局所最適解からの脱出可能。

## 制約の種類

### 1 ハード制約（絶対に違反不可）

```python
# 1. 従業員の勤務可能時間と希望施設
if not emp_avail_matrix.get((w_idx, d_idx, h_idx), False):
    model.Add(x[f_idx, w_idx, d_idx, h_idx] == 0)

# 2. 同時に複数施設での勤務不可
model.Add(sum(x[f_idx, w_idx, d_idx, h_idx] for f_idx in F_indices) <= 1)

# 3. works_on_dayの定義
model.Add(hours_worked_this_day > 0).OnlyEnforceIf(works_on_day[w_idx, d_idx])
```

* 従業員の希望シフト時間を厳密に守る。シフト希望外の時間帯には配置しない
* 物理的な不可能な同時勤務を禁止。ただし施設間移動時間は考慮していない。

### 2 ソフト制約（違反時にペナルティ）

```python
# 1. 最大連続勤務日数
consecutive_days = sum(works_on_day[w_idx, d] 
    for d in range(d_idx_start, d_idx_start + max_consecutive_setting + 1))
excess = model.NewIntVar(0, max_consecutive_setting + 1, 'consecutive_excess')
model.Add(consecutive_days - max_consecutive_setting == excess)
soft_penalty_terms.append(excess * consecutive_penalty)

# 2. 週の最大勤務日数
# 3. 1日の最大労働時間
# 4. 各時間帯の必要人数
```

* **連続勤務日数制限**

  * 疲労を考慮した健康管理のため。
  * デフォルトペナルティ: 20,000 / 日
* **週間勤務日数制限**

  * 雇用契約条件の遵守のため。
  * デフォルトペナルティ: 10,000 / 日
* **1日の最大労働時間**

  * 労働時間の上限規制を考慮。
  * デフォルトペナルティ: 30,000 / 時間
* **必要人数の充足**

  * 清掃件数に対する必要人数の確保。
  * 常駐義務の遵守のため。
  * デフォルトペナルティ: 50000 / 名

##### 目的関数（最小化しなければいけないコスト）

* **人件費**: 従業員の時給 x 勤務時間
* **ペナルティコスト**: ソフト制約違反によるペナルティの合計

```python
model.Minimize(
    sum(objective_terms) +    # 総人件費
    sum(soft_penalty_terms)   # ソフト制約違反のペナルティ
)
```

## 最適化の結果

### 1 最適化前

##### 初期状態

* 変数の数: 1,028,280個
* ブール変数: 1,008,000個
* 整数変数: 9,720個

##### 前処理後

* 変数の数: 18,218個
* ブール変数: 15,400個
* 整数変数: 1,231個

### 2 最適化の進行

##### スタート状態

* 初期解のコスト値: 413,891,818

##### 主要な改善ポイント

1. 大幅な改善フェーズ(6-10秒):
   * 413,891,818 → 375,665,599
   * 約9%の改善
2. 中盤の改善(15-20秒):
   * 375,665,599 → 328,576,863
   * さらに12%の改善
3. 後半の微調整(20-1085秒):
   * 328,576,863 → 315,130,444
   * 約4%の追加改善

### 3 最終結果

* 変数数（前処理後）: 18,218
* 最終目的関数値（コスト）: 315,130,444
* 初期解からの改善率: **約24%**
* 計算時間: 1,085秒（約18分）

  * 社用PCではここまでが限界（急激に重くなった）
  * CPUコア数: 12

### 4 改善の内訳

1. ハード制約を満たしつつ
2. ソフト制約違反のペナルティを最小化
3. 総人件費を削減

## 解の品質評価

制約の充足状況は以下の順序で重要視

1. **必須条件** （ハード制約）

* 勤務可能時間の遵守: ✅
* 同時複数施設勤務の禁止: ✅
* 最低必要人数の確保: ✅

1. **望ましい条件** （ソフト制約）

* 連続勤務制限: 部分的に満たす
* 週間労働時間制限: 部分的に満たす
* 1日の労働時間制限: 部分的に満たす

## 特徴的な挙動

1. **早期の急速な改善**
   * 最初の10秒で大きな改善を達成
   * 初期の解の質が大きく向上
2. **中盤の安定的な改善**
   * 様々な探索手法を組み合わせて徐々に改善
   * 20秒前後で比較的 良質な解を発見
3. **後半の微細な調整**
   * 長時間かけて少しずつ解を改善
   * 最終的な改善は小幅なものが多い

## まとめ

* 全体として約24%のコスト削減を達成
* 早期に大きな改善を見つけ、その後細かい調整で解を改善
* 複数の最適化手法を組み合わせることで、効果的な解探索を実現
